# 06-高级主题

本文档介绍 Galay MCP 的高级功能、性能优化技巧和扩展开发。

## 高级功能

### 1. 自定义传输层

虽然 Galay MCP 提供了 Stdio 和 HTTP 两种传输方式，但你可以实现自定义传输层。

#### 传输层接口

```cpp
class CustomTransport {
public:
    // 读取一条 JSON-RPC 消息
    std::expected<JsonString, McpError> readMessage() {
        // 实现消息读取逻辑
        // 返回完整的 JSON-RPC 消息字符串
    }

    // 写入一条 JSON-RPC 消息
    std::expected<void, McpError> writeMessage(const JsonString& message) {
        // 实现消息写入逻辑
    }

    // 检查连接状态
    bool isConnected() const {
        return m_connected;
    }

private:
    bool m_connected = false;
};
```

#### WebSocket 传输示例

```cpp
#include "galay-mcp/common/McpTypes.h"
#include <websocketpp/config/asio_no_tls.hpp>
#include <websocketpp/server.hpp>

using namespace galay::mcp;

class WebSocketTransport {
public:
    using Server = websocketpp::server<websocketpp::config::asio>;
    using ConnectionPtr = Server::connection_ptr;

    WebSocketTransport(uint16_t port) : m_port(port) {
        m_server.init_asio();
        m_server.set_message_handler([this](auto hdl, auto msg) {
            handleMessage(hdl, msg);
        });
    }

    void start() {
        m_server.listen(m_port);
        m_server.start_accept();
        m_server.run();
    }

    void sendMessage(ConnectionPtr conn, const JsonString& message) {
        m_server.send(conn, message, websocketpp::frame::opcode::text);
    }

private:
    void handleMessage(websocketpp::connection_hdl hdl, Server::message_ptr msg) {
        JsonString payload = msg->get_payload();
        // 处理 JSON-RPC 消息
        auto response = processJsonRpc(payload);
        sendMessage(m_server.get_con_from_hdl(hdl), response);
    }

    JsonString processJsonRpc(const JsonString& request) {
        // 解析和处理 JSON-RPC 请求
        // 返回 JSON-RPC 响应
        return "{}";
    }

    Server m_server;
    uint16_t m_port;
};
```

### 2. 流式响应

对于大型数据或长时间运行的操作，可以实现流式响应。

#### 服务器端流式工具

```cpp
#include "galay-mcp/server/McpHttpServer.h"
#include <sstream>

using namespace galay::mcp;

class StreamingTool {
public:
    void registerTool(McpHttpServer& server) {
        auto schema = SchemaBuilder()
            .addString("query", "Search query", true)
            .build();

        server.addTool("stream_search", "Stream search results", schema,
            [this](const JsonElement& args, std::expected<JsonString, McpError>& result)
            -> kernel::Coroutine {
                JsonObject obj;
                if (!JsonHelper::GetObject(args, obj)) {
                    result = std::unexpected(McpError::invalidParams("Invalid arguments"));
                    co_return;
                }

                std::string query;
                auto queryVal = obj["query"];
                if (queryVal.error() || !JsonHelper::GetStringValue(queryVal.value(), query)) {
                    result = std::unexpected(McpError::invalidParams("Missing query"));
                    co_return;
                }

                // 流式返回结果
                JsonWriter writer;
                writer.StartObject();
                writer.Key("results");
                writer.StartArray();

                for (int i = 0; i < 100; ++i) {
                    // 模拟搜索
                    co_await std::suspend_always{};

                    writer.StartObject();
                    writer.Key("id");
                    writer.Number(i);
                    writer.Key("title");
                    writer.String("Result " + std::to_string(i));
                    writer.EndObject();
                }

                writer.EndArray();
                writer.EndObject();
                result = writer.TakeString();
            }
        );
    }
};
```

### 3. 工具链（Tool Chaining）

实现工具之间的调用链，一个工具的输出作为另一个工具的输入。

```cpp
#include "galay-mcp/server/McpStdioServer.h"

using namespace galay::mcp;

class ToolChain {
public:
    void setupTools(McpStdioServer& server) {
        // 工具 1: 获取用户信息
        auto getUserSchema = SchemaBuilder()
            .addInteger("user_id", "User ID", true)
            .build();

        server.addTool("get_user", "Get user information", getUserSchema,
            [](const JsonElement& args) -> std::expected<JsonString, McpError> {
                JsonObject obj;
                if (!JsonHelper::GetObject(args, obj)) {
                    return std::unexpected(McpError::invalidParams("Invalid arguments"));
                }

                auto userIdVal = obj["user_id"];
                if (userIdVal.error()) {
                    return std::unexpected(McpError::invalidParams("Missing user_id"));
                }

                int64_t userId = userIdVal.get_int64().value();

                JsonWriter writer;
                writer.StartObject();
                writer.Key("user_id");
                writer.Number(userId);
                writer.Key("name");
                writer.String("User " + std::to_string(userId));
                writer.Key("email");
                writer.String("user" + std::to_string(userId) + "@example.com");
                writer.EndObject();

                return writer.TakeString();
            }
        );

        // 工具 2: 获取用户订单（依赖工具 1）
        auto getOrdersSchema = SchemaBuilder()
            .addString("user_email", "User email", true)
            .build();

        server.addTool("get_orders", "Get user orders", getOrdersSchema,
            [](const JsonElement& args) -> std::expected<JsonString, McpError> {
                JsonObject obj;
                if (!JsonHelper::GetObject(args, obj)) {
                    return std::unexpected(McpError::invalidParams("Invalid arguments"));
                }

                std::string email;
                auto emailVal = obj["user_email"];
                if (emailVal.error() || !JsonHelper::GetStringValue(emailVal.value(), email)) {
                    return std::unexpected(McpError::invalidParams("Missing user_email"));
                }

                JsonWriter writer;
                writer.StartObject();
                writer.Key("email");
                writer.String(email);
                writer.Key("orders");
                writer.StartArray();
                writer.StartObject();
                writer.Key("order_id");
                writer.Number(1001);
                writer.Key("amount");
                writer.Number(99.99);
                writer.EndObject();
                writer.EndArray();
                writer.EndObject();

                return writer.TakeString();
            }
        );
    }
};
```

### 4. 资源订阅（Resource Subscription）

实现资源变更通知机制。

```cpp
#include "galay-mcp/server/McpHttpServer.h"
#include <unordered_map>
#include <vector>
#include <mutex>

using namespace galay::mcp;

class ResourceSubscription {
public:
    void setupResource(McpHttpServer& server) {
        server.addResource(
            "live://system/status",
            "System Status",
            "Real-time system status",
            "application/json",
            [this](const std::string& uri, std::expected<std::string, McpError>& result)
            -> kernel::Coroutine {
                // 获取当前状态
                auto status = getCurrentStatus();

                JsonWriter writer;
                writer.StartObject();
                writer.Key("timestamp");
                writer.Number(std::time(nullptr));
                writer.Key("cpu");
                writer.Number(status.cpu);
                writer.Key("memory");
                writer.Number(status.memory);
                writer.EndObject();

                result = writer.TakeString();
                co_return;
            }
        );
    }

    void subscribe(const std::string& uri, std::function<void(const std::string&)> callback) {
        std::lock_guard<std::mutex> lock(m_mutex);
        m_subscribers[uri].push_back(callback);
    }

    void notifySubscribers(const std::string& uri, const std::string& data) {
        std::lock_guard<std::mutex> lock(m_mutex);
        auto it = m_subscribers.find(uri);
        if (it != m_subscribers.end()) {
            for (auto& callback : it->second) {
                callback(data);
            }
        }
    }

private:
    struct SystemStatus {
        double cpu;
        double memory;
    };

    SystemStatus getCurrentStatus() {
        // 获取系统状态
        return {50.0, 60.0};
    }

    std::mutex m_mutex;
    std::unordered_map<std::string, std::vector<std::function<void(const std::string&)>>> m_subscribers;
};
```

### 5. 工具权限控制

实现基于角色的访问控制（RBAC）。

```cpp
#include "galay-mcp/server/McpStdioServer.h"
#include <unordered_map>
#include <unordered_set>

using namespace galay::mcp;

class PermissionManager {
public:
    enum class Role {
        Admin,
        User,
        Guest
    };

    void addRole(const std::string& userId, Role role) {
        m_userRoles[userId] = role;
    }

    void addToolPermission(const std::string& toolName, Role minRole) {
        m_toolPermissions[toolName] = minRole;
    }

    bool checkPermission(const std::string& userId, const std::string& toolName) {
        auto userIt = m_userRoles.find(userId);
        if (userIt == m_userRoles.end()) {
            return false;  // 用户不存在
        }

        auto toolIt = m_toolPermissions.find(toolName);
        if (toolIt == m_toolPermissions.end()) {
            return true;  // 工具无权限限制
        }

        return static_cast<int>(userIt->second) >= static_cast<int>(toolIt->second);
    }

private:
    std::unordered_map<std::string, Role> m_userRoles;
    std::unordered_map<std::string, Role> m_toolPermissions;
};

class SecureServer {
public:
    SecureServer(McpStdioServer& server, PermissionManager& pm)
        : m_server(server), m_permManager(pm) {}

    void addSecureTool(const std::string& name, const std::string& description,
                       const JsonString& schema, PermissionManager::Role minRole,
                       std::function<std::expected<JsonString, McpError>(const JsonElement&)> handler) {
        m_permManager.addToolPermission(name, minRole);

        m_server.addTool(name, description, schema,
            [this, name, handler](const JsonElement& args) -> std::expected<JsonString, McpError> {
                // 从上下文获取用户 ID（实际实现需要从请求中提取）
                std::string userId = getCurrentUserId();

                if (!m_permManager.checkPermission(userId, name)) {
                    return std::unexpected(McpError::invalidParams("Permission denied"));
                }

                return handler(args);
            }
        );
    }

private:
    std::string getCurrentUserId() {
        // 从请求上下文获取用户 ID
        return "user123";
    }

    McpStdioServer& m_server;
    PermissionManager& m_permManager;
};
```

## 性能优化

### 1. JSON 解析优化

#### 复用 JsonDocument

```cpp
class OptimizedServer {
public:
    std::expected<JsonString, McpError> handleRequest(const JsonString& request) {
        // 复用 parser
        auto doc = m_parser.Parse(request);
        if (!doc) {
            return std::unexpected(McpError::parseError("Invalid JSON"));
        }

        // 处理请求
        return processRequest(doc.value());
    }

private:
    simdjson::dom::parser m_parser;  // 复用 parser
};
```

#### 避免不必要的序列化

```cpp
// 不好：多次序列化
JsonWriter writer1;
writer1.StartObject();
writer1.Key("data");
writer1.String("value");
writer1.EndObject();
std::string json1 = writer1.TakeString();

JsonWriter writer2;
writer2.StartObject();
writer2.Key("result");
writer2.String(json1);  // 嵌套 JSON 字符串
writer2.EndObject();

// 好：直接构建
JsonWriter writer;
writer.StartObject();
writer.Key("result");
writer.StartObject();
writer.Key("data");
writer.String("value");
writer.EndObject();
writer.EndObject();
```

### 2. 连接池优化

#### HTTP 连接复用

```cpp
class OptimizedHttpClient {
public:
    OptimizedHttpClient(kernel::Runtime& runtime)
        : m_runtime(runtime) {
        // 预创建连接
        for (int i = 0; i < 10; ++i) {
            auto client = std::make_unique<McpHttpClient>(m_runtime);
            m_connectionPool.push_back(std::move(client));
        }
    }

    kernel::Coroutine callTool(const std::string& toolName, const JsonString& args) {
        // 从池中获取连接
        auto client = acquireConnection();

        std::expected<JsonString, McpError> result;
        if (auto __await_result = co_await client->callTool(toolName, args, result); !__await_result) {
            // 错误处理
        }

        // 归还连接
        releaseConnection(std::move(client));

        co_return result;
    }

private:
    std::unique_ptr<McpHttpClient> acquireConnection() {
        std::lock_guard<std::mutex> lock(m_mutex);
        if (m_connectionPool.empty()) {
            return std::make_unique<McpHttpClient>(m_runtime);
        }
        auto client = std::move(m_connectionPool.back());
        m_connectionPool.pop_back();
        return client;
    }

    void releaseConnection(std::unique_ptr<McpHttpClient> client) {
        std::lock_guard<std::mutex> lock(m_mutex);
        m_connectionPool.push_back(std::move(client));
    }

    kernel::Runtime& m_runtime;
    std::vector<std::unique_ptr<McpHttpClient>> m_connectionPool;
    std::mutex m_mutex;
};
```

### 3. 缓存优化

#### 工具列表缓存

```cpp
class CachedServer {
public:
    const JsonString& getToolsList() {
        std::lock_guard<std::mutex> lock(m_cacheMutex);

        if (m_toolsListCache.empty() || m_toolsListDirty) {
            m_toolsListCache = buildToolsList();
            m_toolsListDirty = false;
        }

        return m_toolsListCache;
    }

    void addTool(const std::string& name, const std::string& description,
                 const JsonString& schema, ToolHandler handler) {
        // 添加工具
        m_tools[name] = {description, schema, handler};

        // 标记缓存为脏
        std::lock_guard<std::mutex> lock(m_cacheMutex);
        m_toolsListDirty = true;
    }

private:
    JsonString buildToolsList() {
        JsonWriter writer;
        writer.StartArray();

        for (const auto& [name, tool] : m_tools) {
            writer.StartObject();
            writer.Key("name");
            writer.String(name);
            writer.Key("description");
            writer.String(tool.description);
            writer.EndObject();
        }

        writer.EndArray();
        return writer.TakeString();
    }

    struct Tool {
        std::string description;
        JsonString schema;
        ToolHandler handler;
    };

    std::unordered_map<std::string, Tool> m_tools;
    JsonString m_toolsListCache;
    bool m_toolsListDirty = true;
    std::mutex m_cacheMutex;
};
```

### 4. 批量操作

#### 批量工具调用

```cpp
class BatchClient {
public:
    kernel::Coroutine callToolsBatch(
        const std::vector<std::pair<std::string, JsonString>>& requests
    ) {
        std::vector<std::expected<JsonString, McpError>> results;
        results.reserve(requests.size());

        for (const auto& [toolName, args] : requests) {
            std::expected<JsonString, McpError> result;
            if (auto __await_result = co_await m_client.callTool(toolName, args, result); !__await_result) {
                // 错误处理
            }
            results.push_back(result);
        }

        co_return results;
    }

private:
    McpHttpClient m_client;
};
```

## 扩展开发

### 1. 自定义 Schema 验证

```cpp
#include "galay-mcp/common/McpSchemaBuilder.h"

class CustomSchemaValidator {
public:
    static bool validate(const JsonElement& data, const JsonString& schema) {
        auto schemaDoc = JsonDocument::Parse(schema);
        if (!schemaDoc) {
            return false;
        }

        // 实现自定义验证逻辑
        return validateRecursive(data, schemaDoc.value().Root());
    }

private:
    static bool validateRecursive(const JsonElement& data, const JsonElement& schema) {
        JsonObject schemaObj;
        if (!JsonHelper::GetObject(schema, schemaObj)) {
            return false;
        }

        // 检查类型
        auto typeVal = schemaObj["type"];
        if (typeVal.error()) {
            return true;  // 无类型限制
        }

        std::string type;
        if (!JsonHelper::GetStringValue(typeVal.value(), type)) {
            return false;
        }

        // 验证类型
        if (type == "string" && !data.is_string()) {
            return false;
        } else if (type == "number" && !data.is_number()) {
            return false;
        } else if (type == "boolean" && !data.is_bool()) {
            return false;
        } else if (type == "object" && !data.is_object()) {
            return false;
        } else if (type == "array" && !data.is_array()) {
            return false;
        }

        // 更多验证逻辑...

        return true;
    }
};
```

### 2. 插件系统

```cpp
#include "galay-mcp/server/McpStdioServer.h"
#include <dlfcn.h>

class PluginManager {
public:
    struct Plugin {
        void* handle;
        std::string name;
        std::function<void(McpStdioServer&)> init;
    };

    bool loadPlugin(const std::string& path, McpStdioServer& server) {
        void* handle = dlopen(path.c_str(), RTLD_LAZY);
        if (!handle) {
            std::cerr << "Failed to load plugin: " << dlerror() << '\n';
            return false;
        }

        // 获取初始化函数
        using InitFunc = void(*)(McpStdioServer&);
        auto init = reinterpret_cast<InitFunc>(dlsym(handle, "plugin_init"));
        if (!init) {
            std::cerr << "Failed to find plugin_init: " << dlerror() << '\n';
            dlclose(handle);
            return false;
        }

        // 初始化插件
        init(server);

        Plugin plugin;
        plugin.handle = handle;
        plugin.name = path;
        m_plugins.push_back(plugin);

        return true;
    }

    ~PluginManager() {
        for (auto& plugin : m_plugins) {
            dlclose(plugin.handle);
        }
    }

private:
    std::vector<Plugin> m_plugins;
};

// 插件示例
extern "C" void plugin_init(McpStdioServer& server) {
    auto schema = SchemaBuilder()
        .addString("message", "Message to echo", true)
        .build();

    server.addTool("echo", "Echo message", schema,
        [](const JsonElement& args) -> std::expected<JsonString, McpError> {
            JsonObject obj;
            if (!JsonHelper::GetObject(args, obj)) {
                return std::unexpected(McpError::invalidParams("Invalid arguments"));
            }

            std::string message;
            auto msgVal = obj["message"];
            if (msgVal.error() || !JsonHelper::GetStringValue(msgVal.value(), message)) {
                return std::unexpected(McpError::invalidParams("Missing message"));
            }

            JsonWriter writer;
            writer.StartObject();
            writer.Key("echo");
            writer.String(message);
            writer.EndObject();

            return writer.TakeString();
        }
    );
}
```

### 3. 中间件系统

```cpp
class Middleware {
public:
    virtual ~Middleware() = default;

    virtual std::expected<JsonString, McpError> process(
        const JsonString& request,
        std::function<std::expected<JsonString, McpError>(const JsonString&)> next
    ) = 0;
};

class LoggingMiddleware : public Middleware {
public:
    std::expected<JsonString, McpError> process(
        const JsonString& request,
        std::function<std::expected<JsonString, McpError>(const JsonString&)> next
    ) override {
        std::cout << "[REQUEST] " << request << '\n';

        auto result = next(request);

        if (result) {
            std::cout << "[RESPONSE] " << result.value() << '\n';
        } else {
            std::cout << "[ERROR] " << result.error().message() << '\n';
        }

        return result;
    }
};

class AuthMiddleware : public Middleware {
public:
    std::expected<JsonString, McpError> process(
        const JsonString& request,
        std::function<std::expected<JsonString, McpError>(const JsonString&)> next
    ) override {
        // 验证请求
        if (!validateAuth(request)) {
            return std::unexpected(McpError::invalidParams("Authentication failed"));
        }

        return next(request);
    }

private:
    bool validateAuth(const JsonString& request) {
        // 实现认证逻辑
        return true;
    }
};

class MiddlewareChain {
public:
    void use(std::unique_ptr<Middleware> middleware) {
        m_middlewares.push_back(std::move(middleware));
    }

    std::expected<JsonString, McpError> execute(
        const JsonString& request,
        std::function<std::expected<JsonString, McpError>(const JsonString&)> handler
    ) {
        return executeMiddleware(0, request, handler);
    }

private:
    std::expected<JsonString, McpError> executeMiddleware(
        size_t index,
        const JsonString& request,
        std::function<std::expected<JsonString, McpError>(const JsonString&)> handler
    ) {
        if (index >= m_middlewares.size()) {
            return handler(request);
        }

        return m_middlewares[index]->process(request,
            [this, index, handler](const JsonString& req) {
                return executeMiddleware(index + 1, req, handler);
            }
        );
    }

    std::vector<std::unique_ptr<Middleware>> m_middlewares;
};
```

## 调试和监控

### 1. 请求追踪

```cpp
class RequestTracer {
public:
    struct Trace {
        std::string requestId;
        std::chrono::steady_clock::time_point startTime;
        std::chrono::steady_clock::time_point endTime;
        std::string method;
        bool success;
        std::string error;
    };

    std::string startTrace(const std::string& method) {
        std::string requestId = generateRequestId();

        Trace trace;
        trace.requestId = requestId;
        trace.startTime = std::chrono::steady_clock::now();
        trace.method = method;

        std::lock_guard<std::mutex> lock(m_mutex);
        m_traces[requestId] = trace;

        return requestId;
    }

    void endTrace(const std::string& requestId, bool success, const std::string& error = "") {
        std::lock_guard<std::mutex> lock(m_mutex);

        auto it = m_traces.find(requestId);
        if (it != m_traces.end()) {
            it->second.endTime = std::chrono::steady_clock::now();
            it->second.success = success;
            it->second.error = error;

            // 记录到日志
            logTrace(it->second);
        }
    }

private:
    std::string generateRequestId() {
        static std::atomic<uint64_t> counter{0};
        return "req-" + std::to_string(counter.fetch_add(1));
    }

    void logTrace(const Trace& trace) {
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(
            trace.endTime - trace.startTime
        ).count();

        std::cout << "[TRACE] " << trace.requestId
                  << " method=" << trace.method
                  << " duration=" << duration << "ms"
                  << " success=" << (trace.success ? "true" : "false");

        if (!trace.error.empty()) {
            std::cout << " error=" << trace.error;
        }

        std::cout << '\n';
    }

    std::unordered_map<std::string, Trace> m_traces;
    std::mutex m_mutex;
};
```

### 2. 性能监控

```cpp
class PerformanceMonitor {
public:
    void recordRequest(const std::string& method, std::chrono::milliseconds duration) {
        std::lock_guard<std::mutex> lock(m_mutex);

        auto& stats = m_methodStats[method];
        stats.count++;
        stats.totalDuration += duration;
        stats.minDuration = std::min(stats.minDuration, duration);
        stats.maxDuration = std::max(stats.maxDuration, duration);
    }

    void printStats() {
        std::lock_guard<std::mutex> lock(m_mutex);

        std::cout << "=== Performance Statistics ===\n";
        for (const auto& [method, stats] : m_methodStats) {
            auto avgDuration = stats.totalDuration / stats.count;

            std::cout << method << ":\n"
                      << "  Count: " << stats.count << '\n'
                      << "  Avg: " << avgDuration.count() << "ms\n"
                      << "  Min: " << stats.minDuration.count() << "ms\n"
                      << "  Max: " << stats.maxDuration.count() << "ms\n";
        }
    }

private:
    struct MethodStats {
        size_t count = 0;
        std::chrono::milliseconds totalDuration{0};
        std::chrono::milliseconds minDuration{std::chrono::milliseconds::max()};
        std::chrono::milliseconds maxDuration{0};
    };

    std::unordered_map<std::string, MethodStats> m_methodStats;
    std::mutex m_mutex;
};
```

## 最佳实践总结

### 1. 性能优化

- 复用 JSON parser 和 writer
- 使用连接池
- 缓存频繁访问的数据
- 批量处理请求

### 2. 安全性

- 实现权限控制
- 验证所有输入
- 使用 HTTPS 传输
- 记录审计日志

### 3. 可维护性

- 使用中间件分离关注点
- 实现插件系统
- 添加详细的日志
- 编写单元测试

### 4. 可扩展性

- 设计清晰的接口
- 支持自定义传输层
- 提供钩子和回调
- 文档化扩展点

## 下一步

- [API 参考](02-API参考.md) - 完整的 API 文档
- [使用指南](03-使用指南.md) - 详细的使用说明
- [示例代码](04-示例代码.md) - 实用示例
- [性能测试](05-性能测试.md) - 性能基准和优化
